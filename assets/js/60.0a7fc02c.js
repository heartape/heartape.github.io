(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{519:function(t,s,e){"use strict";e.r(s);var r=e(0),_=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_1-介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-介绍"}},[t._v("#")]),t._v(" 1.介绍")]),t._v(" "),s("p",[t._v("scan属于Redis key部分的命令，用于替代keys在大数据量情况下的使用。\nkeys命令的时间复杂度为O(n)，在大数据量的情况下必定会卡顿，所以就只能选择scan。")]),t._v(" "),s("h2",{attrs:{id:"_2-命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-命令"}},[t._v("#")]),t._v(" 2.命令")]),t._v(" "),s("blockquote",[s("p",[t._v("命令参数: SCAN cursor MATCH [pattern] COUNT [count]")])]),t._v(" "),s("blockquote",[s("p",[t._v("命令实例: SCAN 0 MATCH * COUNT 100")])]),t._v(" "),s("ul",[s("li",[t._v("cursor是redis提供的下一次查询起始位置，第一次为0，最后一次也是0，实现闭环。")]),t._v(" "),s("li",[t._v("pattern与keys使用方式一致。")]),t._v(" "),s("li",[t._v("count则是每一次的遍历数量。")])]),t._v(" "),s("p",[t._v("由于SCAN是分次进行，而且redis也没有mysql事务类似的复杂设计，所以遍历途中会有查询重复的问题。")]),t._v(" "),s("h2",{attrs:{id:"_3-分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-分析"}},[t._v("#")]),t._v(" 3.分析")]),t._v(" "),s("p",[t._v("redis中key在存储时会通过hash取模来确定存储位置，并在元素过多时进行rehash。\n由于SCAN命令会分多次执行，渐进式rehash也是分多次执行，两者交叉执行时如果不进行特殊处理，查询必然会重复或者遗漏数据。")]),t._v(" "),s("blockquote",[s("p",[t._v("0 + 4 ==> 0，如果查询0未缩容，查询4已缩容就不会查询，则遗漏的4桶内的key")])]),t._v(" "),s("p",[t._v("在使用scan命令时， 如果dbsize = 4，cursor参数可能是这样的：")]),t._v(" "),s("blockquote",[s("p",[t._v("10进制==> 0 -> 2 -> 1 -> 3 -> 0\n2进制==> 00 -> 10 -> 01 -> 11 -> 00\n扩容==> 000 -> 100 -> 010 -> 110 -> 001 -> 101 -> 011 -> 111 -> 000")])]),t._v(" "),s("blockquote",[s("p",[t._v("00 ==> 000 + 100，三者对4取模后相等，原位置所有数据读取完了才会读取下一位置。")])]),t._v(" "),s("p",[t._v("在执行SCAN命令时，借由reverse binary iteration算法实现避免了查询遗漏，易导致了查询时游标并不会顺序推进。\n再加上哈希表可能有些位置没有数据，所以每次获得的游标并不固定。")]),t._v(" "),s("p",[t._v("count参数与我们获取的key的数量也会出现不一致，这很好理解。\n因为我们在查询时只提供了cursor用于定位，而每个位置可能有多个元素，所以只能一次性将目标位置所有元素都取出来，直到查出的key的数量大于等于count。")])])}),[],!1,null,null,null);s.default=_.exports}}]);