(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{527:function(t,a,r){"use strict";r.r(a);var s=r(0),e=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-mysql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-mysql"}},[t._v("#")]),t._v(" 1.mysql")]),t._v(" "),a("h3",{attrs:{id:"_1-索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-索引"}},[t._v("#")]),t._v(" 1.索引")]),t._v(" "),a("h3",{attrs:{id:"_2-事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-事务"}},[t._v("#")]),t._v(" 2.事务")]),t._v(" "),a("p",[t._v("事务的特点:")]),t._v(" "),a("ul",[a("li",[t._v("原子性(Atomicity)")]),t._v(" "),a("li",[t._v("一致性(Consistency)")]),t._v(" "),a("li",[t._v("隔离型(Isolation)")]),t._v(" "),a("li",[t._v("持久性(Durability)")])]),t._v(" "),a("h4",{attrs:{id:"redo-log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[t._v("#")]),t._v(" redo log")]),t._v(" "),a("p",[t._v("redo log叫做重做日志，是用来实现事务的持久性。\n该日志文件由两部分组成: 重做日志缓冲（redo log buffer）以及重做日志文件（redo log）。\n前者是在内存中，后者在磁盘中。")]),t._v(" "),a("p",[t._v("mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。\n然后使用后台线程去做缓冲池和磁盘之间的同步。\nredo log的存储是顺序存储，写入性能更好。使用redo log来记录这部分尚未写入数据，防止数据丢失。")]),t._v(" "),a("h4",{attrs:{id:"undo-log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#undo-log"}},[t._v("#")]),t._v(" undo log")]),t._v(" "),a("p",[t._v("undo log叫做回滚日志，用于记录数据被修改前的信息。主要作用就是做事务回滚。")]),t._v(" "),a("h4",{attrs:{id:"锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[t._v("#")]),t._v(" 锁")]),t._v(" "),a("p",[t._v("共享锁(shared lock) -> 读锁\n排他锁(exclusive lock) -> 写锁")]),t._v(" "),a("h4",{attrs:{id:"mvcc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvcc"}},[t._v("#")]),t._v(" mvcc")]),t._v(" "),a("p",[t._v("MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。")]),t._v(" "),a("p",[t._v("InnoDB的 MVCC ，是通过在每行记录的后面保存两个隐藏的列来实现的。\n这两个列， 一个保存了行的创建版本号，一个保存了行的过期版本号。")]),t._v(" "),a("h4",{attrs:{id:"隔离级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别"}},[t._v("#")]),t._v(" 隔离级别")]),t._v(" "),a("ul",[a("li",[t._v("READ UNCOMMITED (读未提交): 不加锁，事物之间公开透明。脏读。")]),t._v(" "),a("li",[t._v("READ COMMITED (读已提交): 写加锁，读mvcc。因为在每次select时都会生成一个版本，所以会读取到其他事务已提交的数据，导致事务内读取前后不一致。不可重读、幻读。")]),t._v(" "),a("li",[t._v("REPEATABLE READ (可重复读): 写加锁，读mvcc。只会在最初select时生成一个版本，但是update, delete, insert等是当前读能操作select不到的数据。幻读。")]),t._v(" "),a("li",[t._v("SERIALIZABLE (串行化): 顺序读写。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);