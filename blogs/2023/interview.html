<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试题总结 | Heartape</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="favicon.ico">
    <script src="/assets/js/bodyClick.js"></script>
    <meta name="description" content="你也想起舞吗">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="/assets/css/0.styles.a1a12807.css" as="style"><link rel="preload" href="/assets/js/app.3b386d26.js" as="script"><link rel="preload" href="/assets/js/3.0afba0d4.js" as="script"><link rel="preload" href="/assets/js/1.d9ada6a7.js" as="script"><link rel="preload" href="/assets/js/48.12d68297.js" as="script"><link rel="prefetch" href="/assets/js/10.3ba0b48a.js"><link rel="prefetch" href="/assets/js/11.d1ce82e2.js"><link rel="prefetch" href="/assets/js/12.abc33c56.js"><link rel="prefetch" href="/assets/js/13.1f1fd4c3.js"><link rel="prefetch" href="/assets/js/14.6c6ab763.js"><link rel="prefetch" href="/assets/js/15.44208822.js"><link rel="prefetch" href="/assets/js/16.0a0d27be.js"><link rel="prefetch" href="/assets/js/17.93cc0748.js"><link rel="prefetch" href="/assets/js/18.ecab2ba6.js"><link rel="prefetch" href="/assets/js/19.874f7d88.js"><link rel="prefetch" href="/assets/js/20.071cd385.js"><link rel="prefetch" href="/assets/js/21.7ae70a4a.js"><link rel="prefetch" href="/assets/js/22.e8326cd3.js"><link rel="prefetch" href="/assets/js/23.e2a53224.js"><link rel="prefetch" href="/assets/js/24.f921c972.js"><link rel="prefetch" href="/assets/js/25.a5a7af93.js"><link rel="prefetch" href="/assets/js/26.3bb61d12.js"><link rel="prefetch" href="/assets/js/27.090fc656.js"><link rel="prefetch" href="/assets/js/28.860a5464.js"><link rel="prefetch" href="/assets/js/29.a24f3733.js"><link rel="prefetch" href="/assets/js/30.4bcff373.js"><link rel="prefetch" href="/assets/js/31.e7038cae.js"><link rel="prefetch" href="/assets/js/32.4f065bb0.js"><link rel="prefetch" href="/assets/js/33.2aecc001.js"><link rel="prefetch" href="/assets/js/34.57e6726a.js"><link rel="prefetch" href="/assets/js/35.d2e758eb.js"><link rel="prefetch" href="/assets/js/36.c4db7e59.js"><link rel="prefetch" href="/assets/js/37.c6d0b314.js"><link rel="prefetch" href="/assets/js/38.8ac0d36a.js"><link rel="prefetch" href="/assets/js/39.8818f776.js"><link rel="prefetch" href="/assets/js/4.2b85a100.js"><link rel="prefetch" href="/assets/js/40.47171523.js"><link rel="prefetch" href="/assets/js/41.06dc9d52.js"><link rel="prefetch" href="/assets/js/42.4ead7f53.js"><link rel="prefetch" href="/assets/js/43.a273b094.js"><link rel="prefetch" href="/assets/js/44.55bad01c.js"><link rel="prefetch" href="/assets/js/45.4613ff13.js"><link rel="prefetch" href="/assets/js/46.671dc75b.js"><link rel="prefetch" href="/assets/js/47.06701395.js"><link rel="prefetch" href="/assets/js/49.0aa29ed7.js"><link rel="prefetch" href="/assets/js/5.8b9dcbfc.js"><link rel="prefetch" href="/assets/js/50.5131ba9b.js"><link rel="prefetch" href="/assets/js/51.bb4cf6f4.js"><link rel="prefetch" href="/assets/js/52.3d1d0fd5.js"><link rel="prefetch" href="/assets/js/53.10b5b03f.js"><link rel="prefetch" href="/assets/js/54.410b4aff.js"><link rel="prefetch" href="/assets/js/55.ba4e8427.js"><link rel="prefetch" href="/assets/js/56.42bf645a.js"><link rel="prefetch" href="/assets/js/57.237e0a77.js"><link rel="prefetch" href="/assets/js/58.fb93ae78.js"><link rel="prefetch" href="/assets/js/59.514dee53.js"><link rel="prefetch" href="/assets/js/6.f1dd7dd8.js"><link rel="prefetch" href="/assets/js/60.360da120.js"><link rel="prefetch" href="/assets/js/61.05c384da.js"><link rel="prefetch" href="/assets/js/62.5bbd8da7.js"><link rel="prefetch" href="/assets/js/63.6e1a3983.js"><link rel="prefetch" href="/assets/js/64.14dd06d1.js"><link rel="prefetch" href="/assets/js/65.69d74131.js"><link rel="prefetch" href="/assets/js/66.b8dcd8ca.js"><link rel="prefetch" href="/assets/js/67.1b00b402.js"><link rel="prefetch" href="/assets/js/68.e17bb0ec.js"><link rel="prefetch" href="/assets/js/69.109e5d0d.js"><link rel="prefetch" href="/assets/js/7.038a3598.js"><link rel="prefetch" href="/assets/js/70.9e87a911.js"><link rel="prefetch" href="/assets/js/71.9b5c23c1.js"><link rel="prefetch" href="/assets/js/72.eb5484e6.js"><link rel="prefetch" href="/assets/js/73.18ac0fb1.js"><link rel="prefetch" href="/assets/js/74.2ed86a73.js"><link rel="prefetch" href="/assets/js/75.5ff6b1b6.js"><link rel="prefetch" href="/assets/js/76.983aeb74.js"><link rel="prefetch" href="/assets/js/77.7a261500.js"><link rel="prefetch" href="/assets/js/78.1558d42c.js"><link rel="prefetch" href="/assets/js/79.7e6714b8.js"><link rel="prefetch" href="/assets/js/8.6361775d.js"><link rel="prefetch" href="/assets/js/80.caad7b03.js"><link rel="prefetch" href="/assets/js/81.02def165.js"><link rel="prefetch" href="/assets/js/82.8579abd9.js"><link rel="prefetch" href="/assets/js/83.74d5c768.js"><link rel="prefetch" href="/assets/js/9.49176af2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a1a12807.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-dad8a512><div data-v-dad8a512><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-dad8a512 data-v-dad8a512><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-dad8a512 data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Heartape</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Heartape</span>
            
          <span data-v-64685f0e>2022 - </span>
          2023
        </a></span></div></div> <div class="hide" data-v-dad8a512><header class="navbar" data-v-dad8a512><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/image/hero.png" alt="Heartape" class="logo"> <span class="site-name">Heartape</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-blog"></i>
      技术
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/docs/java/java-command.html" class="nav-link"><i class="iconfont undefined"></i>
  JAVA
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/frame/spring5.html" class="nav-link"><i class="iconfont undefined"></i>
  框架
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/middleware/mysql.html" class="nav-link"><i class="iconfont undefined"></i>
  中间件
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/tool/git.html" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时光走过了哪里
</a></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-account"></i>
      我在哪里
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/heartape" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://space.bilibili.com/247318527" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-bilibili"></i>
  Bilibili
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="mailto:heartape@163.com" class="nav-link external"><i class="iconfont reco-mail"></i>
  163
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-dad8a512></div> <aside class="sidebar" data-v-dad8a512><div class="personal-info-wrapper" data-v-ca798c94 data-v-dad8a512><img src="/assets/image/hero.png" alt="author-avatar" class="personal-img" data-v-ca798c94> <h3 class="name" data-v-ca798c94>
    Heartape
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>47</h3> <h6 data-v-ca798c94>文章</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>49</h3> <h6 data-v-ca798c94>标签</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-blog"></i>
      技术
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/docs/java/java-command.html" class="nav-link"><i class="iconfont undefined"></i>
  JAVA
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/frame/spring5.html" class="nav-link"><i class="iconfont undefined"></i>
  框架
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/middleware/mysql.html" class="nav-link"><i class="iconfont undefined"></i>
  中间件
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/tool/git.html" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时光走过了哪里
</a></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-account"></i>
      我在哪里
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/heartape" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://space.bilibili.com/247318527" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-bilibili"></i>
  Bilibili
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="mailto:heartape@163.com" class="nav-link external"><i class="iconfont reco-mail"></i>
  163
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>面试题总结</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Heartape</span>
            
          <span data-v-64685f0e>2022 - </span>
          2023
        </a></span></div></div> <div data-v-dad8a512><main class="page"><div class="page-title" style="display:none;"><h1>面试题总结</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>Heartape</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2023-04-18</span></i> <!----> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>mysql</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><h2 id="_1-mysql"><a href="#_1-mysql" class="header-anchor">#</a> 1.mysql</h2> <h3 id="_1-1索引"><a href="#_1-1索引" class="header-anchor">#</a> 1.1索引</h3> <p>为了提升io速度，mysql提供了索引，通过空间换时间的方式，支持更快速地查询。</p> <h4 id="_1-1-1-b-tree"><a href="#_1-1-1-b-tree" class="header-anchor">#</a> 1.1.1.B+TREE</h4> <ul><li>B+TREE因为非叶子节点存储叶子节点的指针，数据都在叶子节点，查找相邻数据时可以通过左右指针来查找，而不用通过树结构往上回溯。非叶子节点可以存储更多的指针，可以指向更多的叶子节点，降低树的深度。</li> <li>相比hash来说，不会存在hash冲突，所以更稳定，并且hash是散列的，不能支持排序和范围查询。</li></ul> <h4 id="_1-1-2-innodb索引的特点"><a href="#_1-1-2-innodb索引的特点" class="header-anchor">#</a> 1.1.2.InnoDB索引的特点</h4> <ul><li>主键索引为聚集索引，同时保存了所有数据（如果没有主键，系统会隐式地创建）。</li> <li>二级索引为非聚集索引，保存了主键值，用于到主键索引二次查询（即回表）。</li></ul> <h4 id="_1-1-3-最左匹配原则"><a href="#_1-1-3-最左匹配原则" class="header-anchor">#</a> 1.1.3.最左匹配原则</h4> <p>联合索引不会保存数据所以当使用索引时，会先拿到主键，再回表拿数据。但当需要查询的数据在索引中时，便可以利用最左匹配原则省去回表环节。比如：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>有一个a,b,c三个字段的联合索引，如果where条件中使用到了a=1,b=2,且查询对象时c时，就可以免去回表; 查询主键同理。  
之所以叫最左匹配原则，是因为它严格要求索引的建立顺序必须条件在左，结果在右，这跟索引的数据结构有关。索引会把a和b字段建立成1对n的关系，所以无法逆向使用最左匹配原则。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="_1-1-4-数据存储"><a href="#_1-1-4-数据存储" class="header-anchor">#</a> 1.1.4.数据存储</h4> <div class="language-text line-numbers-mode"><pre class="language-text"><code>在计算机中，磁盘存储数据最小单元是扇区，一个扇区的大小是512字节。
文件系统中，最小单位是块，一个块大小就是4k;
InnoDB存储引擎最小储存单元是页，一页大小就是16k。
如果一行记录的数据大小为1k，那么单个叶子节点可以存的记录数 =16k/1k =16.
非叶子节点内存放多少指针呢?我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，所以就是8+6=14字节，16k/14B =16*1024B/14B = 1170。
因此，一棵高度为2的B+树，能存放1170 * 16=18720条这样的数据记录。同理一棵高度为3的B+树，能存放1170 *1170 *16 =21902400。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="_1-1-5-性能调优"><a href="#_1-1-5-性能调优" class="header-anchor">#</a> 1.1.5.性能调优</h4> <div class="language-text line-numbers-mode"><pre class="language-text"><code>1.一般来说，有序的主键性能更强。如果主键是十分散列的:
  - 每次插入时都需要寻找插入的位置，效率低下。
  - 由于需要排序，所以需要重新将数据向后移动，页满了以后会进行大量的页分裂操作，需要进行多次io。
  - 由于频繁的页分裂，造成内存碎片化，分配的内存不能充分使用，后续查找数据也跟困难。
2.充分利用最左匹配原则，减少索引的数量，甚至免去回表流程。
3.只建立必要的索引，索引需要大量存储空间，并且在插入删除时需要维护索引，影响性能。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="_1-1-6-索引条件下推"><a href="#_1-1-6-索引条件下推" class="header-anchor">#</a> 1.1.6.索引条件下推</h4> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'李%'</span> <span class="token operator">and</span> age<span class="token operator">=</span><span class="token number">10</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-text line-numbers-mode"><pre class="language-text"><code>在没有索引条件下推的情况下，组合索引满足最左匹配，但是遇到非等值判断时（）匹配停止。之所以匹配停止是因为左边字段的范围查询会导致右边字段乱序，失去索引功能。
索引条件下推会将条件查询从server层下推到存储引擎。
索引分三类：1.Index Key 2.Index Filter 3.Table Filter。
5.6之前，Index Filter、Table Filter都是存储引擎将数据返回server层后，由server层过滤的。
5.6开始，Index Filter下推到存储引擎过滤，且是在回表查询之前过滤，减少回表次数。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="_1-1-7-索引失效"><a href="#_1-1-7-索引失效" class="header-anchor">#</a> 1.1.7.索引失效</h4> <ul><li>违反最左前缀原则</li> <li>有or时有条件没有索引</li> <li>LIKE以通配符开头</li> <li>索引列做特殊操作
<ul><li>使用函数: <code>EXPLAIN SELECT * FROM user_innodb WHERE LEFT(name,3) = 'alan';</code> MySQL 8.0函数索引可以解决<code>ALTER TABLE user_innodb ADD KEY IDX_NAME_LEFT ((left(name,3)));</code></li> <li>使用表达式: <code>EXPLAIN SELECT * FROM user_innodb WHERE id + 1 = 11;</code>转换一下sql可以解决<code>EXPLAIN SELECT * FROM user_innodb WHERE id = 1100000 - 1;</code></li> <li>使用类型转换: <code>EXPLAIN SELECT * FROM user_innodb WHERE phone = 13203398311;</code>(其中phone是字符串类型)</li></ul></li></ul> <p>索引效果较差的情况:</p> <ul><li>唯一性差;</li> <li>频繁更新的字段不用（更新索引消耗）;</li> <li>索引使用&lt;&gt;时;</li> <li>is NULL、 is NOT NULL</li></ul> <h3 id="_1-2-redo-log"><a href="#_1-2-redo-log" class="header-anchor">#</a> 1.2.redo log</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>mysql为了减少硬盘IO提升性能，引入了Boffer Pool(缓冲池)。
查询一条记录，先从Buffer Pool中找，没有命中会从硬盘把一页的数据加载出来，放入到Buffer Pool中。
修改也是会先存到Boffer Pool里头。
然后使用后台线程去做缓冲池和磁盘之间的同步。
此时，便需要使用redo log来记录这部分尚未写入数据，防止数据丢失。

redo log叫做重做日志，是用来实现事务的持久性。
该日志文件由两部分组成: 重做redo log buffer（日志缓冲）以及redo log（重做日志文件），前者是在内存中，后者在磁盘中。

redo log有以下特性:
- 顺序存储，写入性能更好。
- 只要事务一提交，便将redo log buffer刷盘到redo log，保证事务的持久性(innodb_flush_log_at_trx_commit=1)。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="_1-3-multi-version"><a href="#_1-3-multi-version" class="header-anchor">#</a> 1.3.multi-version</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>InnoDB is a multi-version storage engine. 
It keeps information about old versions of changed rows to support transactional features such as concurrency and rollback. 
This information is stored in undo tablespaces in a data structure called a rollback segment.

数据库内部会向数据库中存储的每一行添加三个字段:
DB_TRX_ID: 6-byte。transaction identifier。最后进行插入或更新的事务标识符，没有删除是因为删除在底层就是更新，将特殊标志位更新为已删除。
DB_ROLL_PTR: 7-byte。roll pointer。指向undo log的指针。
DB_ROW_IDInnoDBDB_ROW_ID: 6-byte。row ID。行ID随着新行的插入而单调增加，只会出现在默认生成的主键索引中。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-text line-numbers-mode"><pre class="language-text"><code>Undo logs in the rollback segment are divided into insert and update undo logs. 
Insert undo logs are needed only in transaction rollback and can be discarded as soon as the transaction commits. 
Update undo logs are used also in consistent reads, but they can be discarded only after there is no transaction present for which has assigned a snapshot that in a consistent read could require the information in the update undo log to build an earlier version of a database row.

总结:
- 有事务才会Insert undo log
- undo log可用于事务回滚。
- undo log保存了修改前的数据，可以作为旧版本快照的数据，以供快照读。

注意点:It is recommend that you commit transactions regularly, including transactions that issue only consistent reads. Otherwise, cannot discard data from the update undo logs, and the rollback segment may grow too big, filling up the undo tablespace in which it resides. 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><div class="language-text line-numbers-mode"><pre class="language-text"><code>InnoDB multiversion concurrency control (MVCC) treats secondary indexes differently than clustered indexes. 
Records in a clustered index are updated in-place, and their hidden system columns point undo log entries from which earlier versions of records can be reconstructed. 
Unlike clustered index records, secondary index records do not contain hidden system columns nor are they updated in-place.

When a secondary index column is updated, old secondary index records are delete-marked, new records are inserted, and delete-marked records are eventually purged. 
When a secondary index record is delete-marked or the secondary index page is updated by a newer transaction, looks up the database record in the clustered index. 
In the clustered index, the record's is checked, and the correct version of the record is retrieved from the undo log if the record was modified after the reading transaction was initiated. 

If a secondary index record is marked for deletion or the secondary index page is updated by a newer transaction, the covering index technique is not used. 
Instead of returning values from the index structure, looks up the record in the clustered index. 

However, if the index condition pushdown (ICP) optimization is enabled, and parts of the condition can be evaluated using only fields from the index, the MySQL server still pushes this part of the condition down to the storage engine where it is evaluated using the index. 
If no matching records are found, the clustered index lookup is avoided. 
If matching records are found, even among delete-marked records, looks up the record in the clustered index.

以上主要说明，MVCC对于主键索引和非主键索引的处理并不一致。
由于主键索引存储了数据，通过隐藏的3个字段，可以立即更新然后指向undo log。
而二级索引只能打上已删除的标记，并不立即更新，只插入新的值，为旧的数据打上删除标记。
如果二级索引被其他事务更新或删除，会导致索引失效。但是索引条件下推优化避免索引失效。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="_1-4-锁"><a href="#_1-4-锁" class="header-anchor">#</a> 1.4.锁</h3> <p>在事务中因为需要解决脏读、幻读等问题需要加锁，只会在事务提交时才会被释放。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">-- 通过创建innodb_monitor开启监控</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> innodb_monitor <span class="token punctuation">(</span>a <span class="token keyword">INT</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">INNODB</span><span class="token punctuation">;</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> innodb_monitor<span class="token punctuation">;</span>

<span class="token comment">-- 通过参数开启监控</span>
<span class="token keyword">set</span> <span class="token keyword">GLOBAL</span> innodb_status_output_locks<span class="token operator">=</span><span class="token keyword">ON</span><span class="token punctuation">;</span>
<span class="token keyword">set</span> <span class="token keyword">GLOBAL</span> innodb_status_output_locks<span class="token operator">=</span><span class="token keyword">OFF</span><span class="token punctuation">;</span>

<span class="token comment">-- 查看事务 </span>
<span class="token keyword">select</span>  <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>INNODB_TRX<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="_1-4-1-全局锁、表级锁"><a href="#_1-4-1-全局锁、表级锁" class="header-anchor">#</a> 1.4.1.全局锁、表级锁</h4> <div class="language-text line-numbers-mode"><pre class="language-text"><code>- 全局锁: 全库逻辑备份（mysqldump），命令 `Flush tables with read lock (FTWRL)`，会导致业务停止，主从延迟。
- 表级锁:
  - lock: `unlock tables;`解锁。
    - `lock tables book read;`，当前连接可以读，写报错。其他连接可以读，写等待。
    - `lock tables book write;`，当前连接可以写，读等待。其他连接读写等待。
  - 元数据锁(MDL): 不需要显式使用。增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="_1-4-2-共享锁、排它锁"><a href="#_1-4-2-共享锁、排它锁" class="header-anchor">#</a> 1.4.2.共享锁、排它锁</h4> <div class="language-text line-numbers-mode"><pre class="language-text"><code>- 共享锁(s)`select * from book where id = 1 lock in share mode`: permits the transaction that holds the lock to read a row.
- 排它锁(x)`select * from book where id = 1 for update`: permits the transaction that holds the lock to update or delete a row.a request from some distinct transaction for a lock of either type on cannot be granted immediately. transaction has to wait for transaction to release its lock on row.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="_1-4-3-记录锁、间隙锁、临键锁"><a href="#_1-4-3-记录锁、间隙锁、临键锁" class="header-anchor">#</a> 1.4.3.记录锁、间隙锁、临键锁</h4> <div class="language-text line-numbers-mode"><pre class="language-text"><code>- 记录锁: `select * from student where id = 3 for update`
- 间隙锁:
  - `select * from student where id = 5 for update`（id主键索引，有值3、7，没有5）;
  - `select * from student where id = 35 for update`（age普通索引，有值25、36）
- 临键锁: `select * from student where age = 36 for update`（age普通索引，有值25、36、45）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-text line-numbers-mode"><pre class="language-text"><code>记录锁
+-----------------------+---------------+-------------+------------+-----------+---------------+-------------+-----------+
| ENGINE_TRANSACTION_ID | OBJECT_SCHEMA | OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA |
+-----------------------+---------------+-------------+------------+-----------+---------------+-------------+-----------+
|                  2334 | test_db       | student     | NULL       | TABLE     | IX            | GRANTED     | NULL      |
|                  2334 | test_db       | student     | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 1         |
+-----------------------+---------------+-------------+------------+-----------+---------------+-------------+-----------+

间隙锁(id in (4, 6)会被锁住)
+-----------------------+---------------+-------------+------------+-----------+-----------+-------------+-----------+
| ENGINE_TRANSACTION_ID | OBJECT_SCHEMA | OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE | LOCK_STATUS | LOCK_DATA |
+-----------------------+---------------+-------------+------------+-----------+-----------+-------------+-----------+
|                  2359 | test_db       | student     | NULL       | TABLE     | IX        | GRANTED     | NULL      |
|                  2359 | test_db       | student     | PRIMARY    | RECORD    | X,GAP     | GRANTED     | 6         |
+-----------------------+---------------+-------------+------------+-----------+-----------+-------------+-----------+

间隙锁(age in (26, 35)会被锁住)
+-----------------------+---------------+-------------+------------+-----------+-----------+-------------+-----------+
| ENGINE_TRANSACTION_ID | OBJECT_SCHEMA | OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE | LOCK_STATUS | LOCK_DATA |
+-----------------------+---------------+-------------+------------+-----------+-----------+-------------+-----------+
|                  2435 | test_db       | student     | NULL       | TABLE     | IX        | GRANTED     | NULL      |
|                  2435 | test_db       | student     | age        | RECORD    | X,GAP     | GRANTED     | 36, 15    |
+-----------------------+---------------+-------------+------------+-----------+-----------+-------------+-----------+

临键锁(age in (26, 44) or id=15会被锁住，普通索引命中反而锁得更多)
+-----------------------+---------------+-------------+------------+-----------+---------------+-------------+-----------+
| ENGINE_TRANSACTION_ID | OBJECT_SCHEMA | OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA |
+-----------------------+---------------+-------------+------------+-----------+---------------+-------------+-----------+
|                  2418 | test_db       | student     | NULL       | TABLE     | IX            | GRANTED     | NULL      |
|                  2418 | test_db       | student     | age        | RECORD    | X             | GRANTED     | 36, 15    |
|                  2418 | test_db       | student     | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 15        |
|                  2418 | test_db       | student     | age        | RECORD    | X,GAP         | GRANTED     | 45, 1     |
+-----------------------+---------------+-------------+------------+-----------+---------------+-------------+-----------+
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h4 id="_1-4-4-意向锁"><a href="#_1-4-4-意向锁" class="header-anchor">#</a> 1.4.4.意向锁</h4> <div class="language-text line-numbers-mode"><pre class="language-text"><code>Intention locks are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table.
A lock is granted to a requesting transaction if it is compatible with existing locks, but not if it conflicts with existing locks.
A transaction waits until the conflicting existing lock is released.
If a lock request conflicts with an existing lock and cannot be granted because it would cause deadlock, an error occurs.

大致意思就是，意向锁是一种提前声明，声明了当前表有共享锁或排它锁，省去每次扫描。虽然是表锁，其他事务在不冲突的情况下也可以获取锁。

分类:
- 意向共享锁: a transaction intends to set a shared lock on individual rows in a table.(IS)`SELECT ... FOR SHARE`。
- 意向排它锁: a transaction intends to set an exclusive lock on individual rows in a table.(IX)`SELECT ... FOR UPDATE`。

协议:
- 意向共享锁: Before a transaction can acquire a shared lock on a row in a table, it must first acquire an lock or stronger on the table.
- 意向排它锁: Before a transaction can acquire an exclusive lock on a row in a table, it must first acquire an lock on the table.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment">-- 意向共享锁</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> book <span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">FOR</span> <span class="token keyword">SHARE</span><span class="token punctuation">;</span>
<span class="token comment">-- lock</span>
<span class="token keyword">SELECT</span> ENGINE_TRANSACTION_ID<span class="token punctuation">,</span>OBJECT_SCHEMA<span class="token punctuation">,</span>OBJECT_NAME<span class="token punctuation">,</span>INDEX_NAME<span class="token punctuation">,</span>LOCK_TYPE<span class="token punctuation">,</span>LOCK_MODE<span class="token punctuation">,</span>LOCK_STATUS<span class="token punctuation">,</span>LOCK_DATA <span class="token keyword">from</span> performance_schema<span class="token punctuation">.</span>data_locks<span class="token punctuation">;</span>
<span class="token comment">-- innodb</span>
<span class="token keyword">show</span> <span class="token keyword">engine</span> <span class="token keyword">innodb</span> <span class="token keyword">status</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-text line-numbers-mode"><pre class="language-text"><code>锁信息:
+-----------------------+---------------+-------------+------------+-----------+-----------+-------------+------------------------+
| ENGINE_TRANSACTION_ID | OBJECT_SCHEMA | OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE | LOCK_STATUS | LOCK_DATA              |
+-----------------------+---------------+-------------+------------+-----------+-----------+-------------+------------------------+
|       421428622781656 | test_db       | book        | NULL       | TABLE     | IS        | GRANTED     | NULL                   |
|       421428622781656 | test_db       | book        | PRIMARY    | RECORD    | S         | GRANTED     | 1                      |
|       421428622781656 | test_db       | book        | PRIMARY    | RECORD    | S         | GRANTED     | 2                      |
+-----------------------+---------------+-------------+------------+-----------+-----------+-------------+------------------------+

可以看到IS锁并不用来锁住数据，本质上还是使用记录锁。下面是意向锁锁全表时的记录:

+-----------------------+---------------+-------------+------------+-----------+-----------+-------------+------------------------+
| ENGINE_TRANSACTION_ID | OBJECT_SCHEMA | OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE | LOCK_STATUS | LOCK_DATA              |
+-----------------------+---------------+-------------+------------+-----------+-----------+-------------+------------------------+
|       421428622781656 | test_db       | book        | NULL       | TABLE     | IS        | GRANTED     | NULL                   |
|       421428622781656 | test_db       | book        | PRIMARY    | RECORD    | S         | GRANTED     | supremum pseudo-record |
|       421428622781656 | test_db       | book        | PRIMARY    | RECORD    | S         | GRANTED     | 1                      |
|       421428622781656 | test_db       | book        | PRIMARY    | RECORD    | S         | GRANTED     | 2                      |
+-----------------------+---------------+-------------+------------+-----------+-----------+-------------+------------------------+
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment">-- 意向排它锁</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> book <span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
<span class="token comment">-- lock</span>
<span class="token keyword">SELECT</span> ENGINE_TRANSACTION_ID<span class="token punctuation">,</span>OBJECT_SCHEMA<span class="token punctuation">,</span>OBJECT_NAME<span class="token punctuation">,</span>INDEX_NAME<span class="token punctuation">,</span>LOCK_TYPE<span class="token punctuation">,</span>LOCK_MODE<span class="token punctuation">,</span>LOCK_STATUS<span class="token punctuation">,</span>LOCK_DATA <span class="token keyword">from</span> performance_schema<span class="token punctuation">.</span>data_locks<span class="token punctuation">;</span>
<span class="token comment">-- innodb</span>
<span class="token keyword">show</span> <span class="token keyword">engine</span> <span class="token keyword">innodb</span> <span class="token keyword">status</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-text line-numbers-mode"><pre class="language-text"><code>锁信息:
+-----------------------+---------------+-------------+------------+-----------+---------------+-------------+-----------+
| ENGINE_TRANSACTION_ID | OBJECT_SCHEMA | OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA |
+-----------------------+---------------+-------------+------------+-----------+---------------+-------------+-----------+
|                  2869 | test_db       | book        | NULL       | TABLE     | IX            | GRANTED     | NULL      |
|                  2869 | test_db       | book        | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 1         |
|                  2869 | test_db       | book        | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2         |
+-----------------------+---------------+-------------+------------+-----------+---------------+-------------+-----------+

可以看到IX锁并不用来锁住数据，本质上还是使用记录锁。下面是意向锁锁全表时的记录:

+-----------------------+---------------+-------------+------------+-----------+---------------+-------------+------------------------+
| ENGINE_TRANSACTION_ID | OBJECT_SCHEMA | OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA              |
+-----------------------+---------------+-------------+------------+-----------+---------------+-------------+------------------------+
|                  2869 | test_db       | book        | NULL       | TABLE     | IX            | GRANTED     | NULL                   |
|                  2869 | test_db       | book        | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | supremum pseudo-record |
|                  2869 | test_db       | book        | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 1                      |
|                  2869 | test_db       | book        | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2                      |
+-----------------------+---------------+-------------+------------+-----------+---------------+-------------+------------------------+
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h4 id="_1-4-5-插入意向锁"><a href="#_1-4-5-插入意向锁" class="header-anchor">#</a> 1.4.5.插入意向锁</h4> <p>An insert intention lock is a type of gap lock(间隙锁)。官方文档将插入意向锁作为单独一种。</p> <p>连接1</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> book <span class="token keyword">where</span> id <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text line-numbers-mode"><pre class="language-text"><code>查看锁信息
TABLE LOCK table `test_db`.`book` trx id 2328 lock mode IX
RECORD LOCKS space id 2 page no 4 n bits 72 index PRIMARY of table `test_db`.`book` trx id 2328 lock_mode X

+-----------------------+---------------+-------------+------------+-----------+--------------------+-------------+------------------------+
| ENGINE_TRANSACTION_ID | OBJECT_SCHEMA | OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE          | LOCK_STATUS | LOCK_DATA              |
+-----------------------+---------------+-------------+------------+-----------+--------------------+-------------+------------------------+
|                  2328 | test_db       | book        | NULL       | TABLE     | IX                 | GRANTED     | NULL                   |
|                  2328 | test_db       | book        | PRIMARY    | RECORD    | X                  | GRANTED     | supremum pseudo-record |
|                  2328 | test_db       | book        | PRIMARY    | RECORD    | X                  | GRANTED     | 2                      |
|                  2328 | test_db       | book        | PRIMARY    | RECORD    | X                  | GRANTED     | 3                      |
+-----------------------+---------------+-------------+------------+-----------+--------------------+-------------+------------------------+
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>连接2</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">-- 执行并等待</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token identifier"><span class="token punctuation">`</span>book<span class="token punctuation">`</span></span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'代数'</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>再次查看锁</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>RECORD LOCKS space id 2 page no 4 n bits 72 index PRIMARY of table `test_db`.`book` trx id 2329 lock_mode X insert intention waiting

TABLE LOCK table `test_db`.`book` trx id 2328 lock mode IX
RECORD LOCKS space id 2 page no 4 n bits 72 index PRIMARY of table `test_db`.`book` trx id 2328 lock_mode X

+-----------------------+---------------+-------------+------------+-----------+--------------------+-------------+------------------------+
| ENGINE_TRANSACTION_ID | OBJECT_SCHEMA | OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE          | LOCK_STATUS | LOCK_DATA              |
+-----------------------+---------------+-------------+------------+-----------+--------------------+-------------+------------------------+
|                  2331 | test_db       | book        | NULL       | TABLE     | IX                 | GRANTED     | NULL                   |
|                  2331 | test_db       | book        | PRIMARY    | RECORD    | X,INSERT_INTENTION | WAITING     | supremum pseudo-record |
|                  2328 | test_db       | book        | NULL       | TABLE     | IX                 | GRANTED     | NULL                   |
|                  2328 | test_db       | book        | PRIMARY    | RECORD    | X                  | GRANTED     | supremum pseudo-record |
|                  2328 | test_db       | book        | PRIMARY    | RECORD    | X                  | GRANTED     | 2                      |
|                  2328 | test_db       | book        | PRIMARY    | RECORD    | X                  | GRANTED     | 3                      |
+-----------------------+---------------+-------------+------------+-----------+--------------------+-------------+------------------------+
无法获取到锁，随后insert失败。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_1-5-事务"><a href="#_1-5-事务" class="header-anchor">#</a> 1.5.事务</h3> <p>事务的特点:</p> <ul><li>原子性(Atomicity)</li> <li>一致性(Consistency)</li> <li>隔离型(Isolation)</li> <li>持久性(Durability)</li></ul> <h4 id="_1-5-1-隔离级别"><a href="#_1-5-1-隔离级别" class="header-anchor">#</a> 1.5.1.隔离级别</h4> <div class="language-text line-numbers-mode"><pre class="language-text"><code>- READ UNCOMMITED (读未提交): 不加锁，事物之间公开透明。脏读。
- READ COMMITED (读已提交): 写加锁，读mvcc。因为在每次select时都会生成一个版本，所以会读取到其他事务已提交的数据，导致事务内读取前后不一致。不可重读、幻读。
- REPEATABLE READ (可重复读): 写加锁，读mvcc。只会在最初select时生成一个版本，但是update, delete, insert等是当前读能操作select不到的数据。幻读。
- SERIALIZABLE (串行化): 顺序读写。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_1-5-2-事务等待信息查看"><a href="#_1-5-2-事务等待信息查看" class="header-anchor">#</a> 1.5.2.事务等待信息查看</h4> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span>
  r<span class="token punctuation">.</span>trx_id waiting_trx_id<span class="token punctuation">,</span> 
  r<span class="token punctuation">.</span>trx_mysql_thread_id waiting_thread<span class="token punctuation">,</span> 
  r<span class="token punctuation">.</span>trx_query waiting_query<span class="token punctuation">,</span> 
  b<span class="token punctuation">.</span>trx_id blocking_trx_id<span class="token punctuation">,</span> 
  b<span class="token punctuation">.</span>trx_mysql_thread_id blocking_thread<span class="token punctuation">,</span> 
  b<span class="token punctuation">.</span>trx_query blocking_query 
<span class="token keyword">FROM</span> 
  performance_schema<span class="token punctuation">.</span>data_lock_waits w 
  <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> information_schema<span class="token punctuation">.</span>innodb_trx b 
      <span class="token keyword">ON</span> b<span class="token punctuation">.</span>trx_id <span class="token operator">=</span> w<span class="token punctuation">.</span>blocking_engine_transaction_id 
  <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> information_schema<span class="token punctuation">.</span>innodb_trx r 
      <span class="token keyword">ON</span> r<span class="token punctuation">.</span>trx_id <span class="token operator">=</span> w<span class="token punctuation">.</span>requesting_engine_transaction_id<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="_1-5-3-提交方式"><a href="#_1-5-3-提交方式" class="header-anchor">#</a> 1.5.3.提交方式</h4> <div class="language-text line-numbers-mode"><pre class="language-text"><code>- 显示提交（显式事务）: begin; 'sql'; commit/rollback。此时相当于autocommit=OFF。
- 隐式提交（隐式事务）: 在没有显式开启事务时，会为单个sql开启隐式事务。隐式提交会自动在sql语句后提交。需要autocommit=ON，否则需要手动commit。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>显示提交:</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">update</span> <span class="token identifier"><span class="token punctuation">`</span>book<span class="token punctuation">`</span></span> <span class="token keyword">set</span> <span class="token identifier"><span class="token punctuation">`</span>title<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token string">'牛x'</span> <span class="token keyword">where</span> <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>隐式提交:<br>
连接1</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'autocommit'</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> autocommit <span class="token operator">=</span> <span class="token keyword">OFF</span><span class="token punctuation">;</span>
<span class="token keyword">update</span> <span class="token identifier"><span class="token punctuation">`</span>book<span class="token punctuation">`</span></span> <span class="token keyword">set</span> <span class="token identifier"><span class="token punctuation">`</span>title<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token string">'牛x'</span> <span class="token keyword">where</span> <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>连接2会等待</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">update</span> <span class="token identifier"><span class="token punctuation">`</span>book<span class="token punctuation">`</span></span> <span class="token keyword">set</span> <span class="token identifier"><span class="token punctuation">`</span>title<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token string">'牛xx'</span> <span class="token keyword">where</span> <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_2-elasticsearch"><a href="#_2-elasticsearch" class="header-anchor">#</a> 2.elasticsearch</h2> <h3 id="_2-1-倒排索引"><a href="#_2-1-倒排索引" class="header-anchor">#</a> 2.1 倒排索引</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>整体结构: Term Index -&gt; Term Dictionary -&gt; Posting List

1 分词
倒排索引的建立，第一步就是分词。分词数据如下（分词器不同会有不同的结果）

2 Posting List（倒排表）
在创建索引时，es会为text类型字段创建倒排表，与传统意义上的索引不同，倒排表保存了term对应的文档id，比如: 
&quot;百年&quot; -&gt; [1, 5, 8]
&quot;孤独&quot; -&gt; [3, 6, 8]
不像通常的索引一样在索引里寻找结果，本质上是空间换时间，所以整个字段的倒排表一定会膨胀许多。 
自然，如此庞大的数据不可能全部放到内存，就算放到硬盘也是非常夸张的（数据量越大，数据就越分散，硬盘寻址越慢），所以自然需要压缩数据。

2.1 Frame Of Reference
主要步骤如下:
- 将倒排表转化为差值数组: [1, 5, 8, 56, 216] -&gt; [1, 4, 3, 48, 160]
- 计算是否需要拆分数组: 因为数组拆分后，需要一个byte（内存最小单位）来存储标志位（每一个元素占用的bit数），所以拆分越细，需要的标志位越多。
- 拆分: 3 -&gt; [1, 4, 3] , 7 -&gt; [48, 160]
lucene为了存储bit数据，建立了 byte[][] 用来保存压缩数据,二维数组的优势在于扩容内存消耗较小。

2.2 Roaring Bitmaps
RBM的主要思路是：将32位无符号整数按照高16位分桶（类似前缀），即最多可能有2^16=65536个桶（container）。
有两种container:
1. ArrayContainer,基于数量动态扩容。
2. BitmapContainer，长度固定，length = ((1 &amp;lt;&amp;lt; 16) - 1) &gt;&gt; 6 -&gt; 1023 + 1 ，大小固定memory = length &amp;lt;&amp;lt; 3 &gt;&gt; 10 = 8 byte

2.3 Term Dictionary
就算进行了数据压缩，数据量依旧很大。 es底层选择通过建立Term Dictionary，将单词排序，并通过二分查找提升效率。
aa -&gt; ab -&gt; ba -&gt; bb

2.4 Term Index
如果数据量非常大，term的数量也会很大，将Term Dictionary全部放到内存中不现实。 
Term Index 通过建立FST(Finite State Transducer)，以前缀指向Term Dictionary，极大缩小了term的查找范围。 
Term Index数据量相比Term Dictionary会小很多，将Term Index放进内存可以接受。
a -&gt; aa
     ab
     ac
b -&gt; ba
     bb
     bc
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><h3 id="_2-2-分片、副本"><a href="#_2-2-分片、副本" class="header-anchor">#</a> 2.2 分片、副本</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>Elasticsearch是一个分布式搜索引擎，所以索引通常被分割成分布在多个节点上的被称为分片的元素。
分片作用：1.更好的分布式存储、扩展。2.高效地平行查询。
对于索引来说，一旦创建完成的索引，主分片不可更改。

es为了更好地稳定性和容灾，除了进行必要的索引备份外，副本的添加可以更好地维持集群数据完整性。

当出现某个节点从集群脱离，在集群其他节点的副本，此时会选举出主分片，所以这里就有主分片和副本之间的数据同步问题。
es主分片和副本之间的同步，某人方式是当client请求，增删改时，主分片处理后，将信号并发如各个副本，每个副本完成相应操作后，主分片接受处理完成信号后，向client发送处理结果信息。
那么副本也就和主分片数据实时保证一致，所以副本的作用: 1.保证数据完整性，节点出现异常时，充当主分片。2.优化查询效率，副本的数据和主分片一致，可以充分发挥查询时的效率。

当集群索引出现创建慢、搜索慢时，加机器、加副本并不一定提高查询效率，索引在出现此类问题时，除了在硬件上进行节点的增加，还需要重建索引，重新划分主分片数量，使用别名处理，来替换旧的索引，这样才可以更好地优化性能问题。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="_2-2-1-为什么主分片的数目不能修改"><a href="#_2-2-1-为什么主分片的数目不能修改" class="header-anchor">#</a> 2.2.1 为什么主分片的数目不能修改</h4> <div class="language-text line-numbers-mode"><pre class="language-text"><code># 创建后修改主分片数会失败
PUT index-1/_settings
{
  &quot;number_of_shards&quot;: &quot;3&quot;
}

索引的主分片数index.number_of_shards的值不能够动态设置，只能在索引创建的时候被指定。

1.路由算法
shard_num = hash(_routing)  % num_primary_shards

默认情况下，_routing值就是文档id。
ES使用随机id和Hash算法来确保文档均匀地分配给分片。
当使用自定义id或routing时，id或routing值可能不够随机，造成数据倾斜，部分分片过大。

在这种情况下，可以使用index.routing_partition_size配置来减少倾斜的风险。routing_partition_size越大，数据的分布越均匀。
shard_num =  (hash(_routing) + hash(_id)  % routing_partition_size )  % num_primary_shards

2.请求流程
主节点使用路由来确定文档所属分片，通过集群状态中的内容路由表信息获知分片的副本，轮询将请求发送到集群的所有副本来实现负载均衡。

3.解决方案
- 通过reindex索引重建修改主分片数目
- 将数据保存到多个索引中，然后给索引指定相同的索引别名。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="_2-3-master选举"><a href="#_2-3-master选举" class="header-anchor">#</a> 2.3 Master选举</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>1.角色
主节点(active master)：一般指的是集群中活跃的主节点，每个集群中只能有一个。master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理。
候选节点(master node)：具备master角色的节点默认都有被选举权，即是一个候选节点。候选节点可以参与Master选举过程
投票节点(master node)：每个候选节点默认都有投票权，即每个候选节点默认都是一个投票节点，但如果配置了 voting_only 的候选节点将只有选举权而没有被选举权，即仅投票节点。
专用主节点：一般指的是只保留master角色的候选节点(node.roles: [master])。
仅投票节点：指仅具备选举权，而被阉割了被选举权的节点(node.roles: [master, voting_only])，通常同时配置为data节点。

2.触发选举
- 新节点加入
- 当主节点宕机

3.选举流程
- 节点node向所有比自己大的节点发送选举消息(选举为election消息)
- 如果节点node得不到任何回复(回复为alive消息)，那么节点node成为master，并向所有的其它节点宣布自己是master(宣布为Victory消息)
- 如果node得到了任何回复，node节点就一定不是master，同时等待Victory消息，如果等待Victory超时那么重新发起选举

4.ClusterState
ClusterState是Master向集群中各个节点发送的集群状态，这个状态有一个版本号码。
如果集群状态发生了变化，比如集群新增了节点成员或者有节点成员退出了，那么这个版本号就会加一，比对这个版本号的目的是让拥有最新状态的节点成为Master的优先级最高。

5.Master假死
Master节点承担的职责负载过重的情况下，可能无法即时对组内成员作出响应，这种便是假死。如果a节点假死，于是b节点成为了Master节点，但是在a节点负载减轻之后，又对组内成员作出了响应，成为Master节点。如此反复，整个集群状态就会非常不可靠。
Elasticsearch解决了这个问题。a节点发现Master对自己长时间不作出响应，就会会请求其它节点判断Master节点是否存活。如果有1/2以上节点都认定Master存活，a节点就会放弃发起选举。

6.脑裂
脑裂指一个集群中出现了两个及以上的Master节点。
因为网络问题，集群被分为了多个部分，并且都选举出了master，造成数据错误。
当集群master候选数量不小于3个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题。
当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题。

7.Master降级
- Master发现自己能连接到的其它节点数目小于n/2 + 1，那么master自动降级为candidate。
- Master ping到了发现了其它master，会比较cluster_state的version，如果当前Master的version小，那么主动降级为candidate并主动加入Master节点。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h3 id="_2-4-文档写入"><a href="#_2-4-文档写入" class="header-anchor">#</a> 2.4 文档写入</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到Memory Buffer。
然后定时（默认是每隔1秒）写入到Filesystem Cache，这个从Memory Buffer到Filesystem Cache的过程就叫做refresh。
当然在某些情况下，存在Memory Buffer和Filesystem Cache的数据可能会丢失，ES是通过translog的机制来保证数据的可靠性的。
其实现机制是接收到请求后，同时也会写入到translog中，当Filesystem cache中的数据写入到磁盘中时，才会清除掉，这个过程叫做flush。
在flush过程中，内存中的缓冲将被清除，内容被写入一个新段，段的fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。
flush触发的时机是定时触发（默认30分钟）或者translog变得太大（默认为512M）时。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_2-5-文档更新和删除"><a href="#_2-5-文档更新和删除" class="header-anchor">#</a> 2.5 文档更新和删除</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>删除和更新也都是写操作，但是Elasticsearch中的文档是不可变的，因此不能被删除或者改动以展示其变更；
磁盘上的每个段都有一个相应的.del文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del文件中被标记为删除的文档将不会被写入新段。
在新的文档被创建时，Elasticsearch会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除。新版本的文档被索引到一个新段，旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_2-6-搜索流程"><a href="#_2-6-搜索流程" class="header-anchor">#</a> 2.6 搜索流程</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>搜索被执行成一个两阶段过程，我们称之为Query Then Fetch。
在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。
在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。
每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。
接下来就是取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求获取全部文档并返回结果给客户端。

Query Then Fetch的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确。
DFS Query Then Fetch增加了一个预查询的处理，询问Term和Document frequency，这个评分更准确，但是性能会变差。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_2-7-并发读写"><a href="#_2-7-并发读写" class="header-anchor">#</a> 2.7 并发读写</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；
另外对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。
对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_2-8-集群搜索流程"><a href="#_2-8-集群搜索流程" class="header-anchor">#</a> 2.8 集群搜索流程</h3> <p><img src="/assets/image/es-search.png" alt="集群搜索流程"></p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>1.基本搜索数据流
到达Coordinator -&gt; 索引列表和别名 -&gt; 分片路由 -&gt; 实际搜索 -&gt; 组装文档列表 -&gt; 获取文件 -&gt; 排序和聚合 -&gt; 返回结果

2.到达
当搜索查询通过各种搜索 API 到达时，Elasticsearch 首先了解它。Kibana、应用程序甚至 cURL 等客户端将搜索请求发送到集群节点进行处理。有多种 API 和选项，但几乎所有的 API 和选项都以本质上的搜索结束，尽管或多或少具有复杂性和资源需求。
搜索请求可以发送到任何节点，但较大的集群通常使用具有足够 CPU 和 RAM 的专用协调节点来管理高搜索量并限制协调对数据或其他节点的影响。查询到达的任何节点都将成为此查询的协调节点，并将数据路由到正确的位置，即使大部分实际搜索工作是在保存源索引数据的数据节点上执行的。

3.路由
查询到达协调节点后，必须将其路由到正确的索引、分片和节点以进行搜索。由于查询请求可能涵盖许多索引和分片，因此路由步骤对于将每个索引和分片都放到正确的位置非常重要。
首先，协调器根据查询索引模式或别名构建目标索引列表。这通常是单个索引，但也可以是“logsash-*”之类的模式或指向索引或模式的别名。结果是查询需要搜索的实际索引列表。
然后协调器构建所有目标索引的不同分片的列表。这可能会令人困惑，因为在 Elasticsearch 中，一个不同的分片（带有分片 ID）实际上是一组单一的主副本及其可选的副本副本。
因此，具有 5 个分片和 2 个副本的索引将总共有 15 个分片，但只有 5 个不同的分片，每个分片的 ID 都以 0 开头，因此在这种情况下为 0-4。每个都将有 3 个分片：一个主分片和两个副本。给定的主节点和它的副本共享相同的分片 ID，只是在分片列表中将 primaryOrReplica 设置为“p”或“r”，因此您将看到分片：0/p、0/r 和第二个 0/r（其中每一个也有一个唯一的分配 ID，这是 Elasticsearch 在内部区分它们的方式）。
对于每个索引并基于索引路由选项，协调器决定查询是转到单个不同的分片还是所有分片。大多数查询会转到所有不同的分片，但特定的路由可以确保所有查询的文档都在单个不同的分片中；如果是这样，查询只会转到那个不同的分片。

4.负载
无论查询是针对一个不同的分片还是所有分片，对于涉及的每个分片，协调器都会选择要查询每个分片的实际分片，主分片或副本之一。
因此，如果我们查询具有 5 个分片和 2 个副本的索引，则有 5 个不同的分片，总共有 15 个分片。假设没有配置路由，实际查询将发送到 5 个分片，每个分片从每个不同分片的 3 个副本（1 个主分片，2 个副本）中选择。
默认情况下，这种选择或“平衡”算法大多是随机的，尽管有一些优化，包括支持在最近的查询中表现最好的分片。它也可以通过“首选项”选项在查询的基础上进行控制。
路由过程的结果是要查询的实际分片列表，以及这些分片所在的节点，因为这是协调器需要发送要运行的查询的地方。

5.搜索分片——查询阶段
分片执行实际的搜索（和评分）工作。查询阶段搜索就是这样，搜索与查询匹配的文档。
此搜索的每个分片都会发生几件事：
•Elasticsearch 级别的映射•Lucene 中的Analysis•在 Lucene 中搜索•在 Lucene 中评分
该映射类似于索引时的映射，Elasticsearch 将查询字段映射到底层 Lucene 数据字段和结构，以创建每个段（实际上是一个 Lucene 索引）都可以执行的 Lucene 兼容查询。看起来映射和转换到 Lucene 查询是由每个分片完成的，类似于索引由每个分片完成。
分析与索引时完全相同，查询的文本部分通过相同的分析器运行，例如标记文本、转换为小写和词干等。这样查询文本将最好地匹配这些文件已编入索引。

6.段搜索
分片级搜索实际上是一系列合并在一起的段级搜索（这就是为什么段越少通常性能越好）。由于段正在执行真正的搜索工作，因此大多数缓存也在段级别，这就是您在集群和节点统计信息中看到它们的方式。
段级别的实际搜索过程详细信息取决于查询类型和所需内容。这可以有很大的不同，从简单的术语搜索像 name = “bob” 到复杂的多字段全文搜索在各种语言中。
任何这些搜索的结果通常是一个文档 ID 列表，可以选择对其进行评分和排序以获得相关性。这个列表被称为优先级队列，它的大小取决于查询，默认为 10，但如果查询使用普通分页，它将是 'from+size'，它可以在深度分页时使用大量 RAM。
评分本身是一个复杂的领域，比非评分查询需要更多的资源，特别是如果使用 DTS 模式来提高全局评分结果。我们将把 Lucene 评分留给其他博客。
按任何文档字段（即不是分数）排序是通过 doc 值完成的，因为倒排索引不太适合于此。Doc 值是 Lucene 的序列化列数据存储，它将一个字段的所有数据打包在一起，因此可以快速读取大量值，这非常适合聚合，也适用于排序。默认情况下，除分析字符串外的所有字段都启用它们。
聚合更复杂，因为它们需要一种方法来访问所有匹配的文档，即它们不能使用短列表。它们也适用于“文档值”，而不是倒排索引。该过程因聚合类型而异，在某些情况下，例如术语计数，分片返回为其文档设置的整个聚合大小，协调器会将它们合并在一起。
例如，对于大小为 100 的术语计数，每个分片返回 160 个术语，协调器会将它们合并并排序为最终的 100 个给客户端。每个分片的计数可以通过 shard_size 参数进行调整，默认为 (size * 1.5 + 10)，或者 160 表示大小为 100。
对于指标聚合，例如平均值，它需要所有匹配的文档及其字段数据。目前尚不清楚这是如何完成的，但大概每个分片都提供了自己的平均值和计数，然后协调节点可以将其合并。Min/Max 和其他可能类似的处理。
搜索进程段的注意事项有自己的缓存，用于以下几件事：

6.1.Filter Cache - 给定过滤器的文档 ID 段缓存。这极大地加快了搜索速度，这也是过滤器流行的原因。
6.2.Field Cache — 字段数据值的段缓存。主要在获取阶段稍后使用。
6.3.Page Cache——当然，在 Elasticsearch 之外，用于分段数据。

分片还维护一个query cache，因此它可以在将来返回相同查询的结果。但是，如果索引实际发生更改，则每次索引刷新（默认为 1 秒，更常见的是 30-60 秒）时，此缓存都会失效，因此虽然对繁重的索引不太有用，但它仍然可以帮助搜索大量索引。请注意，此缓存由给定节点上的所有分片共享，最多为堆大小的 1%。
虽然过滤器有缓存，但查询（评分搜索）不是，因此对于查询和任何未缓存的过滤器或字段，搜索必须命中倒排索引以构建文档 ID 列表。可以缓存生成的过滤器结果和字段数据。
请注意，所有搜索都是从刷新或提交的索引段完成的，因此只有在刷新后才会搜索或找到数据。唯一的例外是当客户端通过 ID 执行 GET 获取文档时，在这种情况下，可以在刷新索引之前从 translog 中提取它。

7.Coordinator归集数据
每个分片将返回其最高命中作为文档 ID，而不是整个文档。因此，如果我们有 5 个分片且默认大小为 10，我们将得到 50 个结果。如果涉及多个索引，它们的分片也会返回它们的结果。协调器节点合并这些列表以获得实际的排序列表，并在收集阶段继续为它们获取实际数据。

8.获取阶段——收集
一旦协调器节点有了它需要的最终文档 ID 列表，它将返回到分片以获取实际数据，直到现在它都不需要这些数据。这是第 2 阶段或“收集”过程，它使用对各种分片的多文档 GET 请求来获取文档数据，通常作为 _source 字段。请注意，如果客户端仅要求聚合（大小 = 0），则会跳过此步骤。
请注意，这是协调节点 RAM 可能失控的地方，也是首先拥有协调节点的主要原因之一。这些节点将处理、合并和排序结果所需的 CPU 和 RAM 资源保存在几个易于监控的节点中，重要的是让这些资源密集型进程远离主节点、数据节点和 ML 节点，以执行其他重要工作。
例如，在深度分页中，返回的文档数量将是“from + size”页面，因此来自多个索引和分片的深度页面将收集“number_of_shards * (from + size)”文档，这会变得非常大，吃光了所有的堆。在这种情况下，用户通常使用滚动查询。大文档大小和列表同样会导致 RAM 使用量增加。
聚合通常是根据分片返回的聚合结果构建的，聚合似乎没有获取阶段，但如果查询大小&gt;0，协调器仍会为客户端获取底层文档数据。
一旦协调节点拥有所有文档及其数据和/或聚合，它就会构建最终结果，并在需要时使用元数据和其他元素对其进行增强，然后将它们返回给调用者，过程完成。

9.问题
Elasticsearch 搜索非常快速和强大，尽管它是一个复杂的分布式过程，可以平衡高性能、准确性和功能。更大的实时性和稳定性，即不让大查询炸毁集群。虽然它工作得很好，但事情也确实可能会出问题。
当然，任何数据系统都可能耗尽关键资源，尤其是 CPU 和磁盘 IO 带宽。Elasticsearch 非常依赖这两者，但由于是分布式的，通常很容易根据需要添加更多。
另一个关键资源是 RAM，这是可能发生更多问题的地方。在最近的版本中，在保护系统方面做了很多工作，尤其是断路器的概念，它限制了单个查询和聚合操作可以消耗的 RAM。
查询级别的断路器也用于查询的各个部分，例如字段数据，以防止查询使系统的该部分过载（并提供关于您的查询如何潜在地损害集群的准确报告）。
查询驱动的内存相关问题通常来自字段组合、大聚合、大文档、深分页等。与此相关的是，拥有不适合页面缓存的大索引会导致 I/O 压力，这不会使系统崩溃，但会减慢系统速度。
其他问题包括在搜索过程中超时和分片或节点丢失。通常，Elasticsearch 会使用其他分片重试这些操作，以尝试尽可能完整地回答客户端的查询。注意默认情况下，如果存在内部超时或分片故障，Elasticsearch 将返回部分结果。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br></div></div><h2 id="_3-kafka"><a href="#_3-kafka" class="header-anchor">#</a> 3.kafka</h2> <h3 id="_3-1-生产者分区分配策略"><a href="#_3-1-生产者分区分配策略" class="header-anchor">#</a> 3.1.生产者分区分配策略</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>RoundRobin
当生产者将消息放如到batch中时，会轮询partition依次放入消息。
这样会有一个问题，即batch可能并没有装满便发送到消息队列，导致产生了更多的batch，消耗更多的资源。
当然，在消息发送极快，partition数量较少，同时linger.ms设置较大时，则没有这方面的问题。

Sticky
当生产者将消息放如到batch中时，会优先装满当前batch，然后再到下一个partition。
这样产生更少的batch，降低消息延时，减轻服务压力。
有人会说，这样会导致partition间资源分配不均。
其实在整体上去考虑的话，依旧是均衡的。

其他
- 手动指定分区。
- 未指定分区，但是设置了key，则根据序列化key使用murmur2哈希算法对分区数取模。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_3-2-消费者分区分配策略"><a href="#_3-2-消费者分区分配策略" class="header-anchor">#</a> 3.2.消费者分区分配策略</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>Range(org.apache.kafka.clients.consumer.RangeAssignor)
Range分配策略会以均分的方式分配partition，尽量使每个消费者消费的分区数量是均衡的。
Range分配策略只作用于单个topic。

RoundRobin(org.apache.kafka.clients.consumer.RoundRobinAssignor)
RoundRobin分配策略与Range相似，主要不同点在于RoundRobin分配策略作用于所有topic。
RoundRobin策略会将所有topic根据字典序排序，然后平均分配partition。

Sticky(org.apache.kafka.clients.consumer.StickyAssignor)
Sticky分配策略与RoundRobin相似，主要不同点在于Sticky策略在发生Rebalance时，分区的分配尽量和上一次分配保持相同。
Sticky策略主要是为了优化之前ReBalance时，系统会暂停消费，导致stop the world。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language-text line-numbers-mode"><pre class="language-text"><code>在Sticky策略之前，Rebalance流程大致如下：
- 添加consumer
- consumer会向group发送请求
- group发送Rebalance通知
- 所有consumer清除对partition的订阅状态，随后停止消费（stop the world）
- 所有consumer重新加入group

Sticky主要优化点在于不会清除所有的订阅状态，而是只停止部分超出平均的partition的消费。
  ########  ########  ########         ########  ########  ######## 
  |  P1  |  |  P2  |  |  P3  |         |  P1  |  |  P2  |  |  P3  |
  ########  ########  ########         ########  ########  ########
        |    |            |      ===&gt;      |        |          |
       ########       ########         ########  ########  ######## 
       |  C1  |       |  C2  |         |  C1  |  |  C3  |  |  C2  |
       ########       ########         ########  ########  ########
可以看出，实际上只需要变动一个partition的订阅状态即可。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_3-3-pagecache"><a href="#_3-3-pagecache" class="header-anchor">#</a> 3.3.PageCache</h3> <ul><li>kafka接收到生产者的消息后，通过mmap等方式减少内存拷贝（用户态到内核态的拷贝）。</li> <li>kafka利用了操作系统提供的PageCache，无需管理内存，减少了gc压力。PageCache通过Radix tree搜索树来管理和搜索Page。</li> <li>将消息在内存中的地址信息发送到socket缓冲区。</li> <li>如果长时间没有命中被判定为冷数据，便会从内存中删除。</li> <li>当消费到冷数据时，会从磁盘重新读取数据，并将周围数据一起读取，即所谓的预读。 因为在工程实践中发现，一旦用到一条数据，那么其周围数据大概率也会被用到，减少磁盘io。 另外，过多的partition可能导致服务器磁盘io性能的下降，因为不同partition之间不是连贯的，需要来回寻址。</li> <li>最后，需要发送消费数据时通过DMA gather copy方式，根据socket缓冲区提供的地址信息，直接发送到网卡设备。</li></ul> <p>是否由丢失数据的可能？
kafka生产者在发送数据时有重试机制，成功发送到PageCache并且Follower成功从Leader拉取副本后，会返回成功应答。但注意此时数据都没有落盘。
kafka官方不推荐增加flush()的频率，会极大降低性能，只推荐通过副本来尽力保证数据丢失，毕竟所有副本全部宕机是个极小概率事件。</p> <h3 id="_3-4-ack"><a href="#_3-4-ack" class="header-anchor">#</a> 3.4.ack</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>Kafka的ACK机制，指的是producer的消息发送确认机制。
ACK有3个可选值，分别是1，0，-1 。
1:仅等待leader确认接收。
0:不等待确认。
-1:等待leader确认接收和副本同步完成。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_3-5-offset"><a href="#_3-5-offset" class="header-anchor">#</a> 3.5.offset</h3> <p>Kafka对于offset的处理有两种提交方式</p> <ul><li>自动提交(默认): 由auto_commit_interval_ms控制提交频率。</li> <li>手动提交: 同步手动提交、异步手动提交</li></ul> <p>Kafka自带的topic(__consumer_offsets)用于提交偏移量，通过对每个 group.id 做哈希求模运算Math.abs(groupID.hashCode()) % numPartitions，从而将负载分散到不同的__consumer_offsets分区上。</p> <p>一般为了吞吐量，都会使用自动提交的方式。因为同步手动提交会阻塞消费，而异步提交无法重试只能通过回调补救。
自动提交主要缺点在于，如果存在已经消费但没有提交的消息时，服务宕机或者是网络问题导致的心跳发送失败导致Rebalance，会导致新的消费者从上一次提交的offset开始消费，造成重复消费。所以消费者需要一些幂等的设计。</p> <h2 id="_4-redis"><a href="#_4-redis" class="header-anchor">#</a> 4.redis</h2> <h3 id="_4-1-缓存击穿、缓存穿透、缓存雪崩"><a href="#_4-1-缓存击穿、缓存穿透、缓存雪崩" class="header-anchor">#</a> 4.1 缓存击穿、缓存穿透、缓存雪崩</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>缓存穿透
查询一个一定不存在的数据，导致每次请求都要到数据库去查询，进而给数据库带来压力。
解决方案: 1.对空值进行缓存。2.布隆过滤器、布谷鸟过滤器。

缓存雪崩
缓存中数据大批量同时过期。
解决方案: 随机过期时间。

缓存击穿
热点key在有大量的并发请求的时候过期了
解决方案: 1.加锁，写入缓存后直接都缓存。2.永不过期。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_4-2-内存淘汰策略"><a href="#_4-2-内存淘汰策略" class="header-anchor">#</a> 4.2 内存淘汰策略</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰；
allkeys-lru：当内存不足以容纳新写入数据时，从所有key中使用LRU（最近最少使用）算法进行淘汰。
volatile-lfu：4.0版本新增，当内存不足以容纳新写入数据时，在过期的key中，使用LFU算法进行删除key。
allkeys-lfu：4.0版本新增，当内存不足以容纳新写入数据时，从所有key中使用LFU算法进行淘汰；
volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的key中，随机淘汰数据；。
allkeys-random：当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被淘汰；
noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_4-3-redis的持久化机制"><a href="#_4-3-redis的持久化机制" class="header-anchor">#</a> 4.3 Redis的持久化机制</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>AOF: 采用日志的形式来记录每个写操作，追加到文件中。
    - always: 同步，性能差。
    - everysec: 每一秒写入文件一次。
    - no: 不写入。
RDB: 数据以快照的形式保存到磁盘上。
    - save:停止服务，等待RDB完成。
    - bgsave: fork子进程异步操作。
    - 自动触发: save 300 10(表示300 秒内如果至少有 10 个 key 的值变化，则保存)
一般使用AOF和RDB相结合的方式。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_4-4-redis高可用"><a href="#_4-4-redis高可用" class="header-anchor">#</a> 4.4 Redis高可用</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>1.主从模式
主节点，负责读写操作。从节点，只负责读操作。从节点的数据来自主节点。
主从复制包括全量复制，增量复制两种。一般当slave第一次启动连接master，或者认为是第一次连接，就采用全量复制。全量同步之后，如果再次发生更新，就会触发增量复制。
缺点: 主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。

2.哨兵模式
Sentinel可以监视所有的Redis主节点和从节点，并在被监视的主节点进入下线状态时，自动将下线主服务器属下的某个从节点升级为新的主节点。

3.集群模式
Cluster模式实现了Redis的分布式存储。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_4-5-rehash"><a href="#_4-5-rehash" class="header-anchor">#</a> 4.5 rehash</h3> <div class="language-text line-numbers-mode"><pre class="language-text"><code>由于redis底层实现为hash表，为了避免频繁的hash碰撞，提升查询效率，当hashtable内数据量达到一定程度时，就需要rehash扩展hashtable。
一般来说，负载因子(负载因子 = 哈希表已保存的节点数量/哈希表大小)为1时就会触发rehash，除非在执行持久化命令时可以容忍到5。
redis中的rehash是渐进执行的，每处理一次请求就进行一次单个桶（hashtable单个索引和挂载链表合称为桶）的rehash操作，将rehash的时间成本均摊到每次请求上。

redis内有两个hashtable，其中一个就是在需要rehash时创建，存放rehash临时数据，等到流程结束后销毁。
大致流程如下：hashtable分配内存 -&gt; 重新计算桶内hash -&gt; 转移指针 -&gt; 多次rehash -&gt; hashtable回收内存。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_4-6-scan"><a href="#_4-6-scan" class="header-anchor">#</a> 4.6 scan</h3> <blockquote><p>SCAN cursor MATCH [pattern] COUNT [count]</p></blockquote> <div class="language-text line-numbers-mode"><pre class="language-text"><code>scan属于Redis key部分的命令，用于替代keys在大数据量情况下的使用。因为keys命令的时间复杂度为O(n)，在大数据量的情况下必定会卡顿。
cursor是redis提供的下一次查询起始位置，第一次为0，最后一次也是0，实现闭环。

在使用scan命令时，使用了reverse binary iteration（位反转算法）实现避免了查询遗漏。
再加上哈希表可能有些位置没有数据，所以每次获得的游标并不固定，查询时游标并不会顺序推进。
如果dbsize = 4，cursor参数可能是这样的：
10进制 ==&gt;   0     -&gt;      2      -&gt;     1     -&gt;      3     -&gt;      0
2进制  ==&gt;  00     -&gt;     10      -&gt;    01     -&gt;     11     -&gt;     00
扩容   ==&gt; 000 -&gt; 100 -&gt; 010 -&gt; 110 -&gt; 001 -&gt; 101 -&gt; 011 -&gt; 111 -&gt; 000
00 ==&gt; [000, 100]，取模相等的桶会相邻，而不会分散，即原桶里所有数据读取完了才会读取下一个桶，后面的桶也一定没有遍历过。

缩容扩容类似，只不过会发生重复遍历。[000, 100] ==&gt; 00，如果000已遍历而100没遍历，缩容后还是会遍历。

count参数与我们获取的key的数量会出现不一致，因为count指的是桶（槽）的数量。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">2023/5/18 06:30:04</span></div></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:2;" data-v-248d85d6></canvas></div><!----><div class="RibbonAnimation"></div><div id="goTop" class="hide-cat" data-v-bf92849a></div><div></div><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;left:65px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:1;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div></div></div>
    <script src="/assets/js/app.3b386d26.js" defer></script><script src="/assets/js/3.0afba0d4.js" defer></script><script src="/assets/js/1.d9ada6a7.js" defer></script><script src="/assets/js/48.12d68297.js" defer></script>
  </body>
</html>
